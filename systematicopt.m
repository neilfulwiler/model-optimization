function [scores, guess]  = systematicopt(kgvalues, c1values, c2values, k, times)
% systematicopt systematic optimization
% is a simple approach to optimization by 
% finding the k-min sets of parameter values
% that minimize the objective function
% 
% Parameters:
%   kgvalues,        the values of these
%   c1values,        model parameters that will
%   c2values         be searched
%                       
%   k                the percentage (between 0 and 1)
%                    of parameter points that will be displayed
%                    (the minimum k percentage) 
%
%   times            the number of times we should
%                    iterate over every parameter
%                    set, taking the average as the
%                    score
%
% Returns:
%   scores           the scores for each parameter set                           

% these are related to the system and
% not to my individual usage of it
outputlabel = 'experiment_output.csv';

% these are related to my customized paths,etc.
% in order of decreasing variability
project           = 'stationaryObstacles';

basedir           = '/Users/neilfulwiler/dev/VENLab/neil/';
projectdir        = [basedir '/' project '/'];
targetdir         = [projectdir '/target'];
locoMASdir        = [basedir '/locomotionMAS/'];
datadir           = [projectdir '/data'];

configfile        = [projectdir '/config.xml'];
targetfile        = [targetdir '/' outputlabel];
datafile          = [datadir '/' outputlabel];

% the command the runs locomotionMAS (without the redefinition
% of the parameters, those should be added by the objective function)
cmd = locomotionMAScmd(locoMASdir, configfile, datadir);

% extract the targetdata so we can pass it into
% the objective function (only read from the file once)
% !!ASSUMPTION!! we are defining fields here to be
% {'x' 'y'} which is what the current objective function
% will use but others may not just use these fields
fields = {'x' 'y'};
targetdata = parseAgentData(targetfile, [], fields{:});

     
% the score, generated by taking the average of the objective
% function over 'times' runs
scoref = @(kg, c1, c2) mean(...
        arrayfun(@(x)...
            objfun(cmd, datafile, targetdata, 'kg', kg, 'c1', c1, 'c2', c2),...
            1:times));

% generate a grid of the values we will be using, and
% then run it
[kgp c1p c2p] = meshgrid(kgvalues, c1values, c2values);
scores = arrayfun(scoref, kgp, c1p, c2p);

% sort them and take the bottom k-percent 
[sortedScores sortedIndexes] = sort(scores(:));
kmin          = round(k*numel(sortedScores));
kminScores    = sortedScores(1:kmin);
kminIndexes   = sortedIndexes(1:kmin);
kgpmin        = kgp(kminIndexes);
c1pmin        = c1p(kminIndexes);
c2pmin        = c2p(kminIndexes);

% plot it 
H = scatter3(kgpmin(:), c1pmin(:), c2pmin(:), 15, kminScores, 'filled');

scores = kminScores;
guess  = [kgpmin(1) c1pmin(1) c2pmin(1)];

end
% display it










